<META http-equiv="Content-Type" content="text/html; charset=utf-8"><!-- xml version="1.0" encoding="utf-8"  -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US">
<head><link rel="shortcut icon" type="image/x-png" href="http://spec-zone.ru/favicon.png" />
<title>javac - компилятор языка программирования Java</title>
<meta name="collection" content="reference" />
<meta name="copyright" content="1994, 2011" /><link rel="stylesheet" href="../../../technotes/css/guide.css" />
</head>
<body> <!--tTop-->

<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderindex">

<a href="../../../index.html">Содержание документации</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<h1>javac - компилятор языка программирования Java</h1>
<!-- Spec-zone 336x280 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-2514821055276660"
     data-ad-slot="6945508047"></ins>
<ul>
<li><a href="#synopsis">Резюме</a></li>
<li><a href="#description">Описание</a></li>
<li><a href="#options">Опции</a></li>
<li><a href="#commandlineargfile">Файлы Параметра командной строки</a></li>
<li><a href="#processing">Обработка аннотации</a></li>
<li><a href="#searching">Поиск Типов</a></li>
<li><a href="#proginterface">Программируемый Интерфейс</a></li>
<li><a href="#examples">Примеры</a></li>
<li><a href="#seealso">См. Также</a></li>
</ul>
<h2><a name="synopsis" id="synopsis">РЕЗЮМЕ</a></h2>
<!-- Spec-zone 336x280 H2 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-2514821055276660"
     data-ad-slot="9619772848"></ins>
<pre class="codeblock">
        <b>javac</b> [ options ] [ sourcefiles ] [ classes ] [ @argfiles ]

</pre>
<p>Параметры могут быть в любом порядке.</p>
<dl>
<dt><a href="#options"><code>options</code></a></dt>
<dd>Параметры командной строки.</dd>
<dt><code>sourcefiles</code></dt>
<dd>Один или более исходных файлов, которые будут скомпилированы (такие как MyClass.java).</dd>
<dt><code>classes</code></dt>
<dd>Один или более классов, которые будут обработаны для аннотаций (таких как MyPackage. MyClass).</dd>
<dt><code><a href="#commandlineargfile">@argfiles</a></code></dt>
<dd>Один или более файлов, который перечисляет опции и исходные файлы. <code>-J</code> опции не позволяются в этих файлах.</dd>
</dl>
<!-- ****************************************************** -->
<h2><a name="description" id="description">ОПИСАНИЕ</a></h2>
<!-- Spec-zone 336x280 H2 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-2514821055276660"
     data-ad-slot="9619772848"></ins>
<p><b>javac</b> инструмент читает класс и интерфейсные определения, записанные в языке программирования Java, и компилирует их в файлы класса байт-кода. Это может также обработать аннотации в исходных файлах Java и классах.</p>
<p>Есть два способа передать имена файлов исходного кода к <b>javac</b>:</p>
<ul>
<li>Для небольшого количества исходных файлов просто перечислите имена файлов на командной строке.</li>
<li>Для большого количества исходных файлов перечислите имена файлов в файле, разделенном пробелами или разрывами строки. Затем используйте имя файла списка на <b>javac</b> командной строке, которой предшествуют <b></b>символ.</li>
</ul>
<p>Имена файлов исходного кода должны иметь <code>.java</code> суффиксы, имена файлов класса должны иметь <code>.class</code> у суффиксов, и и источник и файлы класса должны быть корневые имена, которые идентифицируют класс. Например, класс вызывают <code>MyClass</code> был бы записан в вызванном исходном файле <code>MyClass.java</code> и скомпилированный в файл класса байт-кода вызывается <code>MyClass.class</code>.</p>
<p>Внутренние определения классов производят дополнительные файлы класса. У этих файлов класса есть имена, комбинирующие внутренние и внешние имена классов, такой как <code>MyClass$MyInnerClass.class</code>.</p>
<p>Следует расположить исходные файлы в дереве каталогов, которое отражает их дерево пакета. Например, если Вы сохраняете все свои исходные файлы в <b>/ рабочей области</b>, исходном коде для <code>com.mysoft.mypack.MyClass</code> должен быть в <b>/workspace/com/mysoft/mypack/MyClass.java</b>.</p>
<p>По умолчанию компилятор помещает каждый файл класса в тот же самый каталог как его исходный файл. Можно определить разделять целевой каталог с<b>-d</b> (см. <a href="#options">Опции</a>, ниже).</p>
<!-- ****************************************************** -->
<h2><a name="options" id="options">ОПЦИИ</a></h2>
<!-- Spec-zone 336x280 H2 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-2514821055276660"
     data-ad-slot="9619772848"></ins>
<p>У компилятора есть ряд стандартных опций, которые поддерживаются на текущей среде разработки и будут поддерживаться в будущих выпусках. Дополнительный набор нестандартных опций является определенным для текущей виртуальной машины и реализаций компилятора и является подверженным изменениям в будущем. Нестандартные опции начинаются <b>с-X</b>.</p>
<!-- ****************************************************** -->
<h3><a name="standard" id="standard">Стандартные Опции</a></h3>
<dl>
<dt><b>-Akey</b> <i>[=value]</i></dt>
<dd>Опции, чтобы передать к процессорам аннотации. Они не интерпретируются javac непосредственно, но делаются доступными для использования отдельными процессорами. <i>ключ</i> должен быть одним или более идентификаторами, разделенными &quot;.&quot;.</dd>
<dt><b>-</b> <i>путь</i> <b>cp</b> или <i>- путь</i> <b>пути к классу</b></dt>
<dd>Определите, где найти пользовательские файлы класса, и (дополнительно) процессоры аннотации и исходные файлы. Этот путь к классу переопределяет пользовательский путь к классу в переменной окружения <b>ПУТИ К КЛАССУ</b>. Если ни <b>ПУТЬ К КЛАССУ</b>, <b>- CP</b>, ни <b>- путь к классу</b> не определяется, пользовательский путь к классу состоит из текущего каталога. См. <a href="classpath.html">Установку Пути к классу</a> для большего количества деталей. <br/><br/> &gt; Если<b>-sourcepath</b> опция не определяется, пользовательский путь к классу также ищется исходные файлы. <br/><br/> Если<b>-processorpath</b> опция не определяется, путь к классу также ищется процессоры аннотации. </dd>
<dt><b>-Djava.ext.dirs=directories</b><i></i></dt>
<dd>Переопределите расположение установленных расширений.</dd>
<dt><b>-Djava.endorsed.dirs=directories</b><i></i></dt>
<dd>Переопределите расположение подтвержденного пути стандартов.</dd>
<dt><i>Каталог</i><b>-d</b></dt>
<dd>Установите целевой каталог для файлов класса. Каталог должен уже существовать; <b>javac</b> не будет создавать это. Если класс является частью пакета, <b>javac</b> помещает файл класса в подкаталог, отражающий имя пакета, создавая каталоги как необходимый. Например, если Вы определяете<b>-d/home/myclasses</b>, и класс вызывают <code>com.mypackage.MyClass</code>, тогда файл класса вызывают <code>/home/myclasses/com/mypackage/MyClass.class</code>. <br/><br/>Если<b>-d</b> не определяется, <b>javac</b> помещает каждый класс файлы в тот же самый каталог как исходный файл, от которого это было сгенерировано. <br/><br/>
<b>Отметьте:</b> каталог, определенный<b>-d</b>, автоматически не добавляется к Вашему пользовательскому пути к классу. </dd>
<dt><b>- осуждение</b></dt>
<dd>Покажите описание каждого использования или переопределения осуждаемого элемента или класса. Без <b>- осуждение</b>, <b>javac</b> показывает сводку исходных файлов, которые используют или переопределяют осуждаемые элементы или классы. <b>- осуждение</b> является сокращением для<b>-Xlint:deprecation</b>.</dd>
<dt><b>- кодирующий</b> <i>кодирование</i></dt>
<dd>Определите имя кодирования исходного файла, такой как <code>EUC-JP and UTF-8</code>. Если <b>- кодирование</b> не определяется, преобразователь значения по умолчанию платформы используется.</dd>
<!-- JDK 7 New option -->
<dt><i>Каталоги</i><b>-endorseddirs</b></dt>
<dd>Переопределите расположение подтвержденного пути стандартов.</dd>
<dt><i>Каталоги</i><a name="extdirs-option" id="extdirs-option"><b>-extdirs</b></a></dt>
<dd>Переопределяет расположение <code>ext</code> каталог. Переменная <i>каталогов</i> является разделенным от двоеточия списком каталогов. Каждый архив JAR в указанных каталогах ищется файлы класса. Все найденные архивы JAR являются автоматически частью пути к классу. <br/><br/> Если Вы кросс-компилируете (компиляция классов против классов начальной загрузки и расширения различной реализации платформы Java), эта опция определяет каталоги, которые содержат классы расширения. См. <a href="#crosscomp-options">Опции Кросс-компиляции</a> для получения дополнительной информации. </dd>
<dt><b>-g</b></dt>
<dd>Генерируйте всю отладочную информацию, включая локальные переменные. По умолчанию только информация о номере строки и исходном файле сгенерирована.</dd>
<dt><b>-g:none</b></dt>
<dd>Не генерируйте отладочную информацию.</dd>
<dt><b>-g:</b> <i>{список ключевого слова}</i></dt>
<dd>Генерируйте только некоторые виды отладочной информации, определенной списком разделенных запятой значений ключевых слов. Допустимые ключевые слова: <dl>
<dt><b>источник</b></dt>
<dd>Отладочная информация исходного файла</dd>
<dt><b>строки</b></dt>
<dd>Отладочная информация номера строки</dd>
<dt><b>вары</b></dt>
<dd>Отладочная информация локальной переменной</dd>
</dl>
</dd>
<dt><b>- справка</b></dt>
<dd>Напечатайте резюме стандартных опций.</dd>
<dt><a name="implicit" id="implicit"><b>- неявный:</b></a> <i>{класс, ни один}</i></dt>
<dd>Управляет генерацией файлов класса для неявно загруженных исходных файлов. Чтобы автоматически генерировать файлы класса, используйте<b>-implicit:class</b>. Чтобы подавить генерацию файла класса, используйте<b>-implicit:none</b>. Если эта опция не определяется, значение по умолчанию должно автоматически генерировать файлы класса. В этом случае компилятор выпустит предупреждение, если какие-либо такие файлы класса будут сгенерированы, также делая обработку аннотации. Предупреждение не будет выпущено, если эта опция будет установлена явно. См. <a href="#searching">Поиск Типов</a>.</dd>
<!-- JDK 7 The -J option is now standard -->
<dt><b>-Joption</b><i></i></dt>
<dd><i>Опцию</i> передачи к средству запуска <b>java</b> вызывает <b>javac</b>. Например,<b>-J-Xms48m</b> устанавливает память запуска в 48 мегабайтов. Это - общее соглашение для<b>-J</b>, чтобы передать опции к базовому VM выполняющиеся приложения, записанные в Java. <br/><br/>
<b>Отметьте:</b> <b>ПУТЬ К КЛАССУ</b>, <b>- путь к классу</b>,<b>-bootclasspath</b>, и<b>-extdirs</b> <i>не</i> определяет классы, используемые, чтобы выполнить <b>javac</b>. Игра с реализацией компилятора таким образом обычно бессмысленна и всегда опасна. Если Вы действительно должны сделать это, используйте<b>-J</b> опцию, чтобы пройти через опции к базовому средству запуска <b>java</b>. </dd>
<dt><b>-nowarn</b></dt>
<dd>Отключите предупреждающие сообщения. У этого есть то же самое значение как<b>-Xlint:none</b>.</dd>
<dt><b>-proc:</b> <i>{ни один, только}</i></dt>
<dd>Средства управления, делаются ли обработка аннотации и/или компиляция.<b>-proc:none</b> означает, что компиляция имеет место без обработки аннотации.<b>-proc:only</b> означает, что только обработка аннотации делается без любой последующей компиляции.</dd>
<dt><b>- процессор class1</b> <i>[class2, class3...]</i></dt>
<dd>Имена процессоров аннотации, чтобы работать. Это обходит процесс открытия по умолчанию.</dd>
<dt><i>Путь</i><b>-processorpath</b></dt>
<dd>Определите, где найти процессоры аннотации; если эта опция не будет использоваться, то путь к классу будет искаться процессоры.</dd>
<dt><i>dir</i><b>-s</b></dt>
<dd>Определите каталог, куда поместить сгенерированные исходные файлы. Каталог должен уже существовать; <b>javac</b> не будет создавать это. Если класс является частью пакета, компилятор помещает исходный файл в подкаталог, отражающий имя пакета, создавая каталоги как необходимый. Например, если Вы определяете<b>-s/home/mysrc</b>, и класс вызывают <code>com.mypackage.MyClass</code>, тогда исходный файл будет помещен в <code>/home/mysrc/com/mypackage/MyClass.java</code>.</dd>
<dt><b>- исходный</b> <i>выпуск</i></dt>
<dd>Определяет версию принятого исходного кода. Следующие значения для <i>выпуска</i> позволяются: <dl>
<dt><b>1.3</b></dt>
<dd>Компилятор <i>не</i> поддерживает утверждения, обобщения, или другие функции языка, представленные после JDK 1.3.</dd>
<dt><b>1.4</b></dt>
<dd>Компилятор принимает код, содержащий утверждения, которые были представлены в JDK 1.4.</dd>
<dt><b>1.5</b></dt>
<dd>Компилятор принимает код, содержащий обобщения и другие функции языка, представленные в JDK 5.</dd>
<dt><b>5</b></dt>
<dd>Синоним для 1.5.</dd>
<dt><b>1.6</b></dt>
<dd>Это - значение по умолчанию. Никакие изменения языка не были представлены в Java SE 6. Однако, о кодирующих ошибках в исходных файлах теперь сообщают как ошибки, вместо предупреждений, как ранее.</dd>
<dt><b>6</b></dt>
<dd>Синоним для 1.6.</dd>
<dt><b>1.7</b></dt>
<dd>Компилятор принимает код с функциями, представленными в JDK 7.</dd>
<dt><b>7</b></dt>
<dd>Синоним для 1.7.</dd>
</dl>
</dd>
<dt><a name="sourcepath" id="sourcepath"><b>-sourcepath</b></a> <i>sourcepath</i></dt>
<dd>Определите путь исходного кода, чтобы искать класс или интерфейсные определения. Как с пользовательским путем к классу, исходные записи пути разделяются двоеточиями (<b>:)</b> и могут быть каталоги, архивы JAR, или архивы ZIP. Если пакеты используются, локальный путь в пределах каталога или архива должен отразить имя пакета. <br/><br/><b>Отметьте:</b> Классы, найденные через путь к классу, могут подвергнуться автоматической перекомпиляции, если их источники также находятся. См. <a href="#searching">Поиск Типов</a>. </dd>
<dt><b>- многословный</b></dt>
<dd>Многословный вывод. Это включает информацию о каждом загруженном классе и каждом скомпилированном исходном файле.</dd>
<dt><b>- версия</b></dt>
<dd>Информация о печатной версии.</dd>
<!-- JDK 7 New option -Werror -->
<dt><b>-Werror</b></dt>
<dd>Оконечная компиляция, если предупреждения происходят.</dd>
<dt><a name="X" id="X"><b>-X</b></a></dt>
<dd>Информация о дисплее о нестандартных опциях и выходе.</dd>
</dl>
<!-- ****************************************************** -->
<h3><a name="crosscomp-options" id="crosscomp-options">Опции кросс-компиляции</a></h3>
<p>По умолчанию классы компилируются против классов начальной загрузки и расширения платформы это <b>javac</b>, поставленный с. Но <b>javac</b> также поддерживает <i>кросс-компиляцию</i>, где классы компилируются против классов начальной загрузки и расширения различной реализации платформы Java. Важно использовать<b>-bootclasspath</b> и<a href="#extdirs-option"><b>-extdirs</b></a>, кросс-компилируя; см. <a href="#crosscomp-example">Пример Кросс-компиляции</a> ниже.</p>
<dl>
<dt><b>- целевая</b> <i>версия</i></dt>
<dd>Генерируйте файлы класса, которые предназначаются для указанной версии VM. Файлы класса будут работать на указанной цели и на более поздних версиях, но не на более ранних версиях VM. Допустимые цели <b>1.1</b> <b>1.2</b> <b>1.3</b> <b>1.4</b> <b>1.5</b> (также <b>5</b>) <b>1.6</b> (также <b>6</b>) и <b>1.7</b> (также <b>7</b>). <br/><br/> Значение по умолчанию для <b>- цель</b> зависит от значения <b>- источник</b>: <ul>
<li>Если - источник <b>не определяется</b>, значение - цель <b>1.7</b></li>
<li>Если - источник <b>1.2</b>, значение - цель <b>1.4</b></li>
<li>Если - источник <b>1.3</b>, значение - цель <b>1.4</b></li>
<li>Для <b>всех других значений</b> - источника, значения <b>- цель</b> является значением <b>- источник</b>.</li>
</ul>
</dd>
<dt><b>-bootclasspath</b> <i>bootclasspath</i></dt>
<dd>Кросс-скомпилируйте против указанного набора классов начальной загрузки. Как с пользовательским путем к классу, загрузитесь, записи пути к классу разделяются двоеточиями (<b>:)</b> и могут быть каталоги, архивы JAR, или архивы ZIP.</dd>
</dl>
<!-- ************************************************** -->
<h3><a name="nonstandard" id="nonstandard">Нестандартные Опции</a></h3>
<dl>
<dt><b>-Xbootclasspath/p:path</b><i></i></dt>
<dd>Предварительно ожидайте к пути к классу начальной загрузки.</dd>
<dt><b>-Xbootclasspath/a:path</b><i></i></dt>
<dd>Добавьте к пути к классу начальной загрузки.</dd>
<dt><b>-Xbootclasspath/:path</b><i></i></dt>
<dd>Расположение переопределения файлов класса начальной загрузки.</dd>
<dt><b>-Xlint</b></dt>
<dd>Включите всем рекомендуемым предупреждениям. В этом выпуске рекомендуется включение всем доступным предупреждениям.</dd>
<dt><b>-Xlint:all</b></dt>
<dd>Включите всем рекомендуемым предупреждениям. В этом выпуске рекомендуется включение всем доступным предупреждениям.</dd>
<dt><b>-Xlint:none</b></dt>
<dd>Отключите все предупреждения.</dd>
<dt><b>-Xlint:name</b><i></i></dt>
<dd>Позвольте предупредить <i>имя</i>. См. <a href="#xlintwarnings">Предупреждения</a> раздела<a href="#xlintwarnings">, Которые Могут быть Включены или Отключены с-Xlint Опцией</a> для списка предупреждений, которым можно включить с этой опцией.</dd>
<dt><b>- Xlint:-имя</b><i></i></dt>
<dd><i>Имя</i> предупреждения отключения. См. <a href="#xlintwarnings">Предупреждения</a> раздела<a href="#xlintwarnings">, Которые Могут быть Включены или Отключены с-Xlint Опцией</a> для списка предупреждений, которые можно отключить с этой опцией.</dd>
<dt><i>Число</i><b>-Xmaxerrs</b></dt>
<dd>Установите максимальное количество ошибок напечатать.</dd>
<dt><i>Число</i><b>-Xmaxwarns</b></dt>
<dd>Установите максимальное количество предупреждений напечатать.</dd>
<dt><i>Имя файла</i><b>-Xstdout</b></dt>
<dd>Отправьте сообщения компилятора именованному файлу. По умолчанию сообщения компилятора идут в <code>System.err</code>.</dd>
<dt><a name="Xprefer" id="Xprefer"><b>-Xprefer:</b></a> <i>{более новый, источник}</i></dt>
<dd>Определите, какой файл считать, когда и исходный файл и файл класса находятся для типа. (См. <a href="#searching">Поиск Типов</a>). Если<i>-Xprefer:newer</i> используется, он читает более новый из источника или файла класса для типа (значение по умолчанию). Если<i>-Xprefer:source</i> опция используется, она читает исходный файл. Используйте<i>-Xprefer:source</i>, когда Вы хотите убедиться, что любые процессоры аннотации могут получить доступ к аннотациям, объявленным с политикой задержания <code>SOURCE</code>.</dd>
<!-- JDK 7 New option -Xpkginfo -->
<dt><b>-Xpkginfo:</b> <i>{всегда, наследство, непустое}</i></dt>
<dd>Определите обработку информационных файлов пакета</dd>
<dt><b>-Xprint</b></dt>
<dd>Распечатайте текстовое представление указанных типов для того, чтобы отладить цели; не выполните ни обработку аннотации, ни компиляцию. Формат вывода может измениться.</dd>
<dt><b>-XprintProcessorInfo</b></dt>
<dd>Информация о печати, о которой аннотациях процессор просят обработать.</dd>
<dt><b>-XprintRounds</b></dt>
<dd>Информация о печати о начальной и последующей аннотации, обрабатывающей раунды.</dd>
</dl>
<!-- ************************************************************* -->
<h3><a name="xlintwarnings" id="xlintwarnings">Предупреждения, Которые Могут быть Включены или Отключены с-Xlint Опцией</a></h3>
<p>Позвольте предупредить <i>имя</i> с опцией<b>-Xlint:name</b><i></i>, где <i>имя</i> является одним из следующих имен предупреждения. Точно так же можно отключить предупреждение <i>имени</i> с опцией <b>- Xlint:-имя</b><i></i>:</p>
<dl>
<dt><i>бросок</i></dt>
<dd>Предупредите о ненужных и избыточных бросках. Например: <pre class="codeblock">
String s = (String)&quot;Hello!&quot;
</pre></dd>
<dt><i>classfile</i></dt>
<dd>Предупредите о проблемах, связанных с classfile содержанием.</dd>
<dt><i>осуждение</i></dt>
<dd>Предупредите об использовании осуждаемых элементов. Например: <pre class="codeblock">
    java.util.Date myDate = new java.util.Date();
    int currentDay = myDate.getDay();
</pre> Метод <code>java.util.Date.getDay</code> был осужден начиная с JDK 1.1. </dd>
<dt><i>отправление-ann</i></dt>
<dd>Предупредите об элементах, которые документируются с <code>@deprecated</code> Javadoc комментируют, но не имеют a <code>@Deprecated</code> аннотация. Например: <pre class="codeblock">
  /**
   * @deprecated As of Java SE 7, replaced by {@link #newMethod()}
   */

  public static void deprecatedMethood() { }

  public static void newMethod() { }
</pre></dd>
<dt><i>divzero</i></dt>
<dd>Предупредите о подразделении постоянным целым числом 0. Например: <pre class="codeblock">
    int divideByZero = 42 / 0;
</pre></dd>
<dt><i>пустой</i></dt>
<dd>Предупредите о пустых операторах после <code>if</code> операторы. Например: <pre class="codeblock">
class E {
    void m() {
        if (true) ;
    }
}
</pre></dd>
<dt><i>fallthrough</i></dt>
<dd>Проверьте, что блоки <tt>switch</tt> для проваливаются случаи и предоставляют предупреждающее сообщение любому, которые находятся. Провалитесь случаи являются случаями в блоке <tt>switch</tt> кроме последнего случая в блоке, код которого не включает оператор <tt>break</tt>, позволяя выполнение кода &quot;провалиться&quot; от того случая до следующего случая. Например, код после метки <tt>case 1</tt> в этом блоке <tt>switch</tt> не заканчивается оператором <tt>break</tt>: <pre class="codeblock">
switch (x) {
case 1:
       System.out.println(&quot;1&quot;);
       //  No break statement here.
case 2:
       System.out.println(&quot;2&quot;);
}
</pre> Если бы флаг <tt>-Xlint:fallthrough</tt> использовался, компилируя этот код, то компилятор испустил бы предупреждение о &quot;возможном, проваливаются в случай,&quot; наряду с номером строки рассматриваемого случая. </dd>
<dt><i>наконец</i></dt>
<dd>Предупредите о <code>finally</code> пункты, которые не могут обычно завершаться. Например: <pre class="codeblock">
  public static int m() {
    try {
      throw new NullPointerException();
    } catch (NullPointerException e) {
      System.err.println(&quot;Caught NullPointerException.&quot;);
      return 1;
    } finally {
      return 0;
    }
  }
</pre> Компилятор генерирует предупреждение для <code>finally</code> блок в этом примере. Когда этот метод вызывают, он возвращает значение <code>0</code>, нет <code>1</code>. A <code>finally</code> блок всегда выполняется когда <code>try</code> блочные выходы. В этом примере, если управление передается <code>catch</code>, тогда выходы метода. Однако, <code>finally</code> блок должен быть выполнен, таким образом, он выполняется, даже при том, что управление было уже передано вне метода. </dd>
<dt><i>опции</i></dt>
<dd>Предупредите о проблемах, касающихся использования параметров командной строки. См. <a href="#crosscomp-example">Пример Кросс-компиляции</a> для примера этого вида предупреждения.</dd>
<dt><i>переопределения</i></dt>
<dd>Предупредите о проблемах относительно переопределений метода. Например, рассмотрите следующие два класса: <pre class="codeblock">
public class ClassWithVarargsMethod {
  void varargsMethod(String... s) { }
}
</pre>
<pre class="codeblock">
public class ClassWithOverridingMethod extends ClassWithVarargsMethod {
  @Override
  void varargsMethod(String[] s) { }
}
</pre> Компилятор генерирует предупреждение, подобное следующему: <br/><br/>
<tt>warning: [override] varargsMethod(String[]) in ClassWithOverridingMethod overrides varargsMethod(String...) in ClassWithVarargsMethod; overriding method is missing '...'</tt> 
<br/><br/> Когда компилятор встречается с varargs методом, он преобразовывает varargs формальный параметр в массив. В методе <code>ClassWithVarargsMethod.varargsMethod</code>, компилятор преобразовывает varargs формальный параметр <code>String... s</code> к формальному параметру <code>String[] s</code>, массив, который соответствует формальный параметр метода <code>ClassWithOverridingMethod.varargsMethod</code>. Следовательно, этот пример компиляции. </dd>
<dt><i>путь</i></dt>
<dd>Предупредите о недопустимых элементах пути и несуществующих каталогах пути на командной строке (относительно пути к классу, исходного пути, и других путей). Такие предупреждения не могут быть подавлены с <code>@SuppressWarnings</code> аннотация. Например: <pre class="codeblock">
javac -Xlint:path -classpath /nonexistentpath Example.java
</pre></dd>
<dt><i>обработка</i></dt>
<dd>Предупредите о проблемах относительно обработки аннотации. Компилятор генерирует это предупреждение, если у Вас есть класс, у которого есть аннотация, и Вы используете процессор аннотации, который не может обработать тот тип исключения. Например, следующее является простым процессором аннотации: <br/><br/>
<strong>Исходный файл <code>AnnoProc.java</code></strong>: <pre class="codeblock">
import java.util.*;
import javax.annotation.processing.*;
import javax.lang.model.*;
import javax.lang.model.element.*;

@SupportedAnnotationTypes(&quot;NotAnno&quot;)
public class AnnoProc extends AbstractProcessor {
    public boolean process(Set&lt;? extends TypeElement&gt; elems, RoundEnvironment renv) {
        return true;
    }

    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latest();
    }
}
</pre>
<strong>Исходный файл <code>AnnosWithoutProcessors.java</code>:</strong> 
<pre class="codeblock">
@interface Anno { }

@Anno
class AnnosWithoutProcessors { }
</pre> Следующие команды компилируют процессор аннотации <code>AnnoProc</code>, тогда выполните этот процессор аннотации против исходного файла <code>AnnosWithoutProcessors.java</code>: <pre class="codeblock">
% javac AnnoProc.java
% javac -cp . -Xlint:processing -processor AnnoProc -proc:only AnnosWithoutProcessors.java
</pre> Когда компилятор выполняет процессор аннотации против исходного файла <code>AnnosWithoutProcessors.java</code>, это генерирует следующее предупреждение: <br/><br/>
<tt>warning: [processing] No processor claimed any of these annotations: Anno</tt> 
<br/><br/> Чтобы решить этот вопрос, можно переименовать аннотацию, определенную и используемую в классе <code>AnnosWithoutProcessors</code> от <code>Anno</code> к <code>NotAnno</code>. </dd>
<dt><i>rawtypes</i></dt>
<dd>Предупредите об операциях непроверенных относительно необработанных типов. Следующий оператор генерирует a <code>rawtypes</code> предупреждение: <pre class="codeblock">
void countElements(List l) { ... }
</pre> Следующее не генерирует a <code>rawtypes</code> предупреждение: <pre class="codeblock">
void countElements(List&lt;?&gt; l) { ... }
</pre>
<code>List</code> необработанный тип. Однако, <code>List&lt;?&gt;</code> неограниченный подстановочный знак параметризованный тип. Поскольку <code>List</code> параметризованный интерфейс, следует всегда определять его параметр типа. В этом примере, <code>List</code> формальный параметр определяется с неограниченным подстановочным знаком (<code>?</code>) как его формальный параметр типа, что означает что <code>countElements</code> метод может принять любое инстанцирование <code>List</code> интерфейс. </dd>
<dt><i>последовательный</i></dt>
<dd>Предупредите о без вести пропавших <code>serialVersionUID</code> определения на сериализуемых классах. Например: <pre class="codeblock">
public class PersistentTime implements Serializable
{
  private Date time;

   public PersistentTime() {
     time = Calendar.getInstance().getTime();
   }

   public Date getTime() {
     return time;
   }
}
</pre> Компилятор генерирует следующее предупреждение: <br/><br/>
<tt>warning: [serial] serializable class PersistentTime has no definition of serialVersionUID</tt> 
<br/><br/> Если сериализуемый класс явно не объявляет названное поле <code>serialVersionUID</code>, тогда время выполнения сериализации вычислит значение по умолчанию <code>serialVersionUID</code> значение для того класса, основанного на различных аспектах класса, как описано в Спецификации Сериализации Объекта Java. Однако, строго рекомендуется, чтобы все сериализуемые классы явно объявили <code>serialVersionUID</code> значения, потому что процесс по умолчанию вычислений <code>serialVersionUID</code> долины очень чувствительны к деталям класса, которые могут измениться в зависимости от реализаций компилятора, и могут таким образом привести к неожиданному <code>InvalidClassExceptions</code> во время десериализации. Поэтому, чтобы гарантировать непротиворечивое <code>serialVersionUID</code> значение через различные реализации компилятора Java, сериализуемый класс должен объявить явное <code>serialVersionUID</code> значение. </dd>
<dt><i>статичный</i></dt>
<dd>Предупредите о проблемах, имеющих отношение к использованию статики. Например: <pre class="codeblock">
class XLintStatic {
    static void m1() { }
    void m2() { this.m1(); }
}
</pre> Компилятор генерирует следующее предупреждение: <pre class="codeblock">
warning: [static] static method should be qualified by type name, XLintStatic, instead of by an expression
</pre> Чтобы решить этот вопрос, можно вызвать статический метод <code>m1</code> следующим образом: <pre class="codeblock">
XLintStatic.m1();
</pre> Альтернативно, можно удалить <code>static</code> ключевое слово от объявления метода <code>m1</code>. </dd>
<dt><i>попробовать</i></dt>
<dd>Предупредите о проблемах, имеющих отношение к использованию <code>try</code> блоки, включая операторы попытки с ресурсами. Например, предупреждение сгенерировано для следующего оператора потому что ресурс <code>ac</code> объявленный в <code>try</code> оператор не используется: <pre class="codeblock">
try ( AutoCloseable ac = getResource() ) {
    // do nothing
}
</pre></dd>
<dt><i>непроверенный</i></dt>
<dd>Дайте больше детали для предупреждений преобразования непроверенных, которые получают мандат Спецификацией языка Java. Например: <pre class="codeblock">
    List l = new ArrayList&lt;Number&gt;();
    List&lt;String&gt; ls = l;       // unchecked warning
</pre> Во время стирания типа, типов <code>ArrayList&lt;Number&gt;</code> и <code>List&lt;String&gt;</code> стать <code>ArrayList</code> и <code>List</code>, соответственно. <br/><br/> Переменная <code>ls</code> имеет параметризованный тип <code>List&lt;String&gt;</code>. Когда <code>List</code> ссылаемый <code>l</code> присваивается <code>ls</code>, компилятор генерирует предупреждение непроверенное; компилятор неспособен определить во время компиляции, и кроме того знает, что JVM не будет в состоянии определить во время выполнения, если <code>l</code> обращается к a <code>List&lt;String&gt;</code> введите; это не делает. Следовательно, загрязнение &quot;кучи&quot; происходит. <br/><br/> Подробно, ситуация с загрязнением &quot;кучи&quot; происходит когда <code>List</code> объект <code>l</code>, чей статический тип <code>List&lt;Number&gt;</code>, присваивается другому <code>List</code> объект, <code>ls</code>, у этого есть различный статический тип, <code>List&lt;String&gt;</code>. Однако, компилятор все еще позволяет это присвоение. Это должно позволить этому присвоению сохранять назад совместимость с версиями Java SE, которые не поддерживают обобщения. Из-за стирания типа, <code>List&lt;Number&gt;</code> и <code>List&lt;String&gt;</code> оба становятся <code>List</code>. Следовательно, компилятор позволяет присвоение объекта <code>l</code>, у которого есть необработанный тип <code>List</code>, к объекту <code>ls</code>. </dd>
<dt><i>varargs</i></dt>
<dd>Предупредите об опасных использованиях переменных параметров (varargs) методы, в частности те, которые содержат non-reifiable параметры. Например: <pre class="codeblock">
public class ArrayBuilder {
  public static &lt;T&gt; void addToList (List&lt;T&gt; listArg, T... elements) {
    for (T x : elements) {
      listArg.add(x);
    }
  }
}
</pre> Компилятор генерирует следующее предупреждение для определения метода <code>ArrayBuilder.addToList</code>: <pre class="codeblock">
warning: [varargs] Possible heap pollution from parameterized vararg type T
</pre> Когда компилятор встречается с varargs методом, он преобразовывает varargs формальный параметр в массив. Однако, язык программирования Java не разрешает создание массивов параметризованных типов. В методе <code>ArrayBuilder.addToList</code>, компилятор преобразовывает varargs формальный параметр <code>T... elements</code> к формальному параметру <code>T[] elements</code>, массив. Однако, из-за стирания типа, компилятор преобразовывает varargs формальный параметр в <code>Object[] elements</code>. Следовательно, есть возможность загрязнения &quot;кучи&quot;. </dd>
</dl>
<!-- JDK 7
     Moved "The -J Option" to Standard Options -->
<!-- ****************************************************** -->
<h2><a name="commandlineargfile" id="commandlineargfile">ФАЙЛЫ ПАРАМЕТРА КОМАНДНОЙ СТРОКИ</a></h2>
<!-- Spec-zone 336x280 H2 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-2514821055276660"
     data-ad-slot="9619772848"></ins>
<p>Чтобы сократить или упростить javac командную строку, можно определить один или более файлов, которые непосредственно содержат параметры <code>javac</code> команда (кроме <code>-J</code> опции). Это позволяет Вам создать javac команды любой длины на любой операционной системе.</p>
<p>Файл параметра может включать javac опции и исходные имена файлов в любой комбинации. Параметры в пределах файла могут быть разделены пробелом или разделены от новой строки. Если имя файла содержит встроенные пробелы, поместите целое имя файла в двойные кавычки.</p>
<p>Имена файлов в пределах файла параметра относительно текущего каталога, не расположения файла параметра. Подстановочные знаки (*) не позволяются в этих списках (такой что касается определения <code>*.java</code>). Использование символа '<tt>@</tt>', чтобы рекурсивно интерпретировать файлы не поддерживается. <code>-J</code> опции не поддерживаются, потому что их передают к средству запуска, которое не поддерживает файлы параметра.</p>
<p>Выполняясь javac, передайте в пути и имени каждого файла параметра с '<tt>@</tt>' ведущий символ. Когда javac встречается с параметром, начинающимся с символьного `<tt>@</tt>', он разворачивает содержание того файла в список параметров.</p>
<!-- ******************************************************* -->
<h3>Пример - Единственный Файл Аргумента</h3>
<p>Вы могли использовать единственный файл параметра, названный&quot;<code>argfile</code>&quot;чтобы содержать все javac параметры:</p>
<pre class="codeblock">
% <b>javac @argfile</b>
</pre>
<p>Этот файл параметра мог содержать содержание обоих файлов, показанных в следующем примере.</p>
<!-- ****************************************************** -->
<h3>Пример - Два Файла Аргумента</h3>
<p>Можно создать два файла параметра - один для javac опций и другого для исходных имен файлов: (Заметьте, что у следующих списков нет никаких символов продолжения строки.)</p>
<p>Создайте файл, названный&quot;<code>options</code>&quot;содержа:</p>
<pre class="codeblock">
     -d classes
     -g
     -sourcepath /java/pubs/ws/1.3/src/share/classes

</pre>
<p>Создайте файл, названный&quot;<code>classes</code>&quot;содержа:</p>
<pre class="codeblock">
     MyClass1.java
     MyClass2.java
     MyClass3.java

</pre>
<p>Вы тогда выполнили бы <b>javac</b> с:</p>
<pre class="codeblock">
  % <b>javac @options @classes</b>

</pre>
<!-- ****************************************************** -->
<h3>Пример - Файлы Аргумента с Путями</h3>
<p>У файлов параметра могут быть пути, но любые имена файлов в файлах относительно текущего рабочего каталога (нет <code>path1</code> или <code>path2</code>):</p>
<pre class="codeblock">
% <b>javac @path1/options @path2/classes</b>
</pre>
<!-- ****************************************************** -->
<h2><a name="processing" id="processing">ОБРАБОТКА АННОТАЦИИ</a></h2>
<!-- Spec-zone 336x280 H2 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-2514821055276660"
     data-ad-slot="9619772848"></ins>
<p><b>javac</b> оказывает прямую поддержку для обработки аннотации, заменяя потребность в отдельном инструменте обработки аннотации, <b>склонном</b>.</p>
<p>API для процессоров аннотации определяется в <code>javax.annotation.processing</code> и <code>javax.lang.model</code> пакеты и подпакеты.</p>
<!-- ****************************************************** -->
<h3>Краткий обзор обработки аннотации</h3>
<p>Если обработка аннотации не отключается с<b>-proc:none</b> опцией, поиски компилятора никаких процессоров аннотации, которые доступны. Путь поиска может быть определен с<b>-processorpath</b> опцией; если это не дается, пользовательский путь к классу используется. Процессоры располагаются посредством названных конфигурационных файлов поставщика услуг <code>  META-INF/services/javax.annotation.processing.Processor</code> на пути поиска. Такие файлы должны содержать имена любых процессоров аннотации, которые будут использоваться, перечисленные один на строку. Альтернативно, процессоры могут быть определены явно, используя - опция <b>процессора</b>.</p>
<p>После сканирования исходных файлов и классов на командной строке, чтобы определить, какие аннотации присутствуют, компилятор запрашивает процессоры, чтобы определить, какие аннотации они обрабатывают. Когда соответствие будет найдено, процессор будет вызван. Процессор может &quot;требовать&quot; аннотаций, которые он обрабатывает, когда никакая дальнейшая попытка не предпринимается, чтобы найти любые процессоры для тех аннотаций. Как только все аннотации требовались, компилятор не ищет дополнительные процессоры.</p>
<p>Если какие-либо процессоры генерируют какие-либо новые исходные файлы, то другой раунд обработки аннотации произойдет: любые недавно сгенерированные исходные файлы будут отсканированы, и аннотации, обработанные как прежде. Любые процессоры, вызванные на предыдущие раунды, будут также вызваны на все последующие раунды. Это продолжается, пока никакие новые исходные файлы не сгенерированы.</p>
<p>После того, как раунд происходит, где никакие новые исходные файлы не сгенерированы, процессоры аннотации будут вызваны в один прошлый раз, чтобы дать им шанс завершить любую работу, которую они, возможно, должны сделать. Наконец, если<b>-proc:only</b> опция не используется, компилятор скомпилирует оригинал и все сгенерированные исходные файлы.</p>
<!-- ****************************************************** -->
<h3>Неявно загруженные исходные файлы</h3>
<p>Чтобы скомпилировать ряд исходных файлов, компилятор, возможно, должен неявно загрузить дополнительные исходные файлы. (См. <a href="#searching">Поиск Типов</a>). Такие файлы в настоящий момент не подвергаются обработке аннотации. По умолчанию компилятор даст предупреждение, если обработка аннотации произошла, и любые неявно загруженные исходные файлы компилируются. См. <a href="#implicit">- неявная</a> опция для способов подавить предупреждение.</p>
<!-- ****************************************************** -->
<h2><a name="searching" id="searching">ПОИСК ТИПОВ</a></h2>
<!-- Spec-zone 336x280 H2 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-2514821055276660"
     data-ad-slot="9619772848"></ins>
<p>Компилируя исходный файл, компилятор часто нуждается в информации о типе, определение которого не появлялось в исходных файлах, данных на командной строке. Компилятор нуждается в информации о типе для каждого класса или интерфейса, используемого, расширенного, или реализованный в исходном файле. Это включает классы и интерфейсы, не явно упомянутые в исходном файле, но которые предоставляют информацию посредством наследования.</p>
<p>Например, когда Вы разделяете <b>java.applet на подклассы. Апплет</b>, Вы также используете классы предка <b>Апплета</b>: <b>java.awt. Панель</b>, <b>java.awt. Контейнер</b>, <b>java.awt. Компонент</b>, и <b>java.lang. Объект</b>.</p>
<p>Когда компилятор нуждается в информации о типе, он ищет исходный файл или файл класса, который определяет тип. Компилятор ищет файлы класса сначала в классах начальной загрузки и расширения, затем в пользовательском пути к классу (который по умолчанию является текущим каталогом). Пользовательский путь к классу определяется, устанавливая переменную окружения <b>ПУТИ К КЛАССУ</b> или при использовании - параметр командной строки <b>пути к классу</b>. (Для получения дополнительной информации см. <a href="classpath.html">Установку Пути к классу</a>).</p>
<p>Если Вы устанавливаете<a href="#sourcepath">-sourcepath</a> опцию, компилятор ищет обозначенный путь исходные файлы; иначе компилятор ищет пользовательский путь к классу и файлы класса и исходные файлы.</p>
<p>Можно определить различные классы начальной загрузки или расширения с<b>-bootclasspath</b> и<b>-extdirs</b> опциями; см. <a href="#crosscomp-options">Опции Кросс-компиляции</a> ниже.</p>
<p>Успешный поиск типа может произвести файл класса, исходный файл, или обоих. Если оба находятся, можно использовать<a href="#Xprefer">-Xprefer</a> опцию, чтобы сообщить компилятору, чтобы использовать. Если <b>более новый</b> дается, компилятор будет использовать более новые из этих двух файлов. Если <b>источник</b> будет дан, то он будет использовать исходный файл. Значение по умолчанию <b>более ново</b>.</p>
<p>Если поиск типа найдет исходный файл для необходимого типа, или отдельно, или в результате установки для<b>-Xprefer</b>, то компилятор считает исходный файл, чтобы получить информацию, в которой это нуждается. Кроме того, это будет значением по умолчанию компилировать исходный файл также. Можно использовать <a href="#implicit">- неявная</a> опция, чтобы определить поведение. Если <b>ни один</b> не будет дан, то никакие файлы класса не будут сгенерированы для исходного файла. Если <b>класс</b> будет дан, то файлы класса будут сгенерированы для исходного файла.</p>
<p>Компилятор, возможно, не обнаруживает потребность в некоторой информации о типе, пока обработка аннотации не полна. Если информация о типе находится в исходном файле и нет <b>- неявная</b> опция дается, компилятор даст предупреждение, что файл компилируется, не будучи подвергающимся обработке аннотации. Чтобы отключить предупреждение, любой определяет файл на командной строке (так, чтобы это подверглось обработке аннотации), или используйте <b>- неявная</b> опция, чтобы определить, должны ли файлы класса быть сгенерированы для таких исходных файлов.</p>
<!-- ****************************************************** -->
<h2><a name="proginterface" id="proginterface">ПРОГРАММИРУЕМЫЙ ИНТЕРФЕЙС</a></h2>
<!-- Spec-zone 336x280 H2 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-2514821055276660"
     data-ad-slot="9619772848"></ins>
<p><b>javac</b> поддерживает новый API Компилятора Java, определенный классами и интерфейсами в <code>javax.tools</code> пакет.</p>
<!-- ****************************************************** -->
<h3>Пример</h3>
<p>Чтобы выполнить компиляцию, используя параметры, поскольку Вы дали бы на командной строке, можно использовать следующее:</p>
<pre class="codeblock">
JavaCompiler javac = ToolProvider.getSystemJavaCompiler();
int rc = javac.run(null, null, null, args);
</pre>
<p>Это запишет любую диагностику в поток стандартного вывода, и возвратит код выхода, который <b>javac</b> дал бы когда вызвано из командной строки.</p>
<p>Можно использовать другие методы на <code>javax.tools.JavaCompiler</code> взаимодействуйте через интерфейс, чтобы обработать диагностику, управление, где файлы читаются из и пишутся и так далее.</p>
<!-- ****************************************************** -->
<h3>Старый Интерфейс</h3>
<p><b>Отметьте:</b> Этот API сохраняется для назад совместимости только; весь новый код должен использовать API Компилятора Java, описанный выше.</p>
<p> <code>com.sun.tools.javac.Main</code> класс обеспечивает два статических метода, чтобы вызвать компилятор из программы:</p>
<pre class="codeblock">
public static int compile(String[] args);
public static int compile(String[] args, PrintWriter out);
</pre>
<p> <code>args</code> параметр представляет любой из параметров командной строки, которые обычно передавали бы к javac программе и обрисовываются в общих чертах в вышеупомянутом разделе <a href="#synopsis">Резюме</a>.</p>
<p> <code>out</code> параметр указывает, где диагностический вывод компилятора направляется.</p>
<p>Возвращаемое значение эквивалентно значению выхода от <b>javac</b>.</p>
<p>Отметьте, что все <b>другие</b> классы и методы, найденные в пакете, имя которого запускается с <code>com.sun.tools.javac</code> (неофициально известный как подпакеты <code>com.sun.tools.javac</code>) являются строго внутренними и подлежат изменению в любое время.</p>
<!-- ****************************************************** -->
<h2><a name="examples" id="examples">ПРИМЕРЫ</a></h2>
<!-- Spec-zone 336x280 H2 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-2514821055276660"
     data-ad-slot="9619772848"></ins>
<!-- ****************************************************** -->
<h3><a name="simpleexamples" id="simpleexamples">Компиляция Простой Программы</a></h3>
<p>Один исходный файл, <code>Hello.java</code>, определяет класс, названный <b>поздравлениями. Привет</b>. <code>greetings</code> каталог является каталогом пакета и для исходного файла и для файла класса и от текущего каталога. Это позволяет нам использовать пользовательский путь к классу по умолчанию. Это также делает ненужным определить разделять целевой каталог с<b>-d</b>.</p>
<pre class="codeblock">
% <b>ls</b>
greetings/
% <b>ls greetings</b>
Hello.java
% <b>cat greetings/Hello.java</b>
package greetings;

public class Hello {
    public static void main(String[] args) {
        for (int i=0; i &lt; args.length; i++) {
            System.out.println(&quot;Hello &quot; + args[i]);
        }
    }
}
% <b>javac greetings/Hello.java</b>
% <b>ls greetings</b>
Hello.class   Hello.java
% <b>java greetings.Hello World Universe Everyone</b>
Hello World
Hello Universe
Hello Everyone
</pre>
<!-- ****************************************************** -->
<h3><a name="multiple-example" id="multiple-example">Компиляция Многократных Исходных файлов</a></h3>
<p>Этот пример компилирует все исходные файлы в пакете <code>greetings</code>.</p>
<pre class="codeblock">
% <b>ls</b>
greetings/
% <b>ls greetings</b>
Aloha.java         GutenTag.java      Hello.java         Hi.java
% <b>javac greetings/*.java</b>
% <b>ls greetings</b>
Aloha.class         GutenTag.class      Hello.class         Hi.class
Aloha.java          GutenTag.java       Hello.java          Hi.java
</pre>
<!-- ****************************************************** -->
<h3><a name="userclasspath" id="userclasspath">Определение Пользовательского Пути к классу</a></h3>
<!-- ****************************************************** -->
<p>Изменив один из исходных файлов в предыдущем примере, мы перекомпилировали это:</p>
<pre class="codeblock">
% <b>pwd</b>
/examples
% <b>javac greetings/Hi.java</b>
</pre>
<p>С тех пор <code>greetings.Hi</code> обращается к другим классам в <code>greetings</code> пакет, компилятор должен найти эти другие классы. Пример выше работ, потому что наш пользовательский путь к классу по умолчанию, оказывается, каталог, содержащий каталог пакета. Но предположите, что мы хотим перекомпилировать этот файл и не беспокойство, о котором каталоге мы находимся в? Затем мы должны добавить <code>/examples</code> к пользовательскому пути к классу. Мы можем сделать это <b>установкой CLASSPATH</b>, но здесь мы будем использовать - опция <b>пути к классу</b>.</p>
<pre class="codeblock">
% <b>javac -classpath /examples /examples/greetings/Hi.java</b>
</pre>
<p>Если мы изменяемся <code>greetings.Hi</code> снова, чтобы использовать утилиту баннера, та утилита также должна быть доступной через пользовательский путь к классу.</p>
<pre class="codeblock">
% <b>javac -classpath /examples:/lib/Banners.jar \
            /examples/greetings/Hi.java</b>
</pre>
<p>Выполнить класс в <code>greetings</code>, мы нуждаемся в доступе оба к <code>greetings</code> и к классам это использует.</p>
<pre class="codeblock">
% <b>java -classpath /examples:/lib/Banners.jar greetings.Hi</b>
</pre>
<!-- ****************************************************** -->
<h3><a name="separating" id="separating">Разделение Исходных файлов и Файлов Класса</a></h3>
<p>Часто имеет смысл сохранять исходные файлы и файлы класса в отдельных каталогах, особенно на крупных проектах. Мы используем<b>-d</b>, чтобы указать на отдельное место назначения файла класса. Так как исходные файлы не находятся в пользовательском пути к классу, мы используем<b>-sourcepath</b>, чтобы помочь компилятору найти их.</p>
<pre class="codeblock">
% <b>ls</b>
classes/  lib/      src/
% <b>ls src</b>
farewells/
% <b>ls src/farewells</b>
Base.java      GoodBye.java
% <b>ls lib</b>
Banners.jar
% <b>ls classes</b>
% <b>javac -sourcepath src -classpath classes:lib/Banners.jar \
            src/farewells/GoodBye.java -d classes</b>
% <b>ls classes</b>
farewells/
% <b>ls classes/farewells</b>
Base.class      GoodBye.class
</pre>
<p><b>Отметьте:</b> компилятор скомпилирован <code>src/farewells/Base.java</code>, даже при том, что мы не определяли это на командной строке. Чтобы проследить автоматические компиляции, используйте <b>- многословная</b> опция.</p>
<!-- ****************************************************** -->
<h3><a name="crosscomp-example" id="crosscomp-example">Пример кросс-компиляции</a></h3>
<p>Здесь мы используем <b>javac</b>, чтобы скомпилировать код, который будет работать на 1.6 VM.</p>
<pre class="codeblock">
% <b>javac -source 1.6 -target 1.6 -bootclasspath jdk1.6.0/lib/rt.jar \
            -extdirs &quot;&quot; OldCode.java</b>
</pre>
<p> <code>-source 1.6</code> опция определяет что версия 1.6 (или 6) языка программирования Java использоваться, чтобы скомпилировать <code>OldCode.java</code>. Опция <b>- предназначается для 1.6</b> опций, гарантирует, что сгенерированные файлы класса будут совместимыми с 1.6 VMs. Отметьте, что в большинстве случаев, значение <b>- целевая</b> опция является значением <b>- исходная</b> опция; в этом примере можно опустить <b>- целевая</b> опция.</p>
<p>Следует определить<b>-bootclasspath</b> опцию, чтобы определить корректную версию классов начальной загрузки ( <code>rt.jar</code> библиотека). В противном случае компилятор генерирует предупреждение:</p>
<pre class="codeblock">
% <b>javac -source 1.6 OldCode.java</b>
warning: [options] bootstrap class path not set in conjunction with -source 1.6
</pre>
<p>Если Вы не определите корректную версию классов начальной загрузки, то компилятор будет использовать старые правила языка (в этом примере, это будет использовать версию 1.6 языка программирования Java), объединенный с новыми классами начальной загрузки, которые могут привести к файлам класса, которые не работают над более старой платформой (в этом случае, Java SE 6), потому что ссылка на несуществующие методы может быть включена.</p>
<!--

<p>The Java Platform JDK's <b>javac</b> would also by default compile against its own bootstrap classes, so we need to tell <b>javac</b> to compile against JDK 1.6 bootstrap classes instead. We do this with <b>-bootclasspath</b> and <b>-extdirs</b>. Failing to do this might allow compilation against a Java Platform API that would not be present on a 1.6 VM and would fail at runtime.</p>

-->
<!-- ****************************************************** -->
<h2><a name="seealso" id="seealso">СМ. ТАКЖЕ</a></h2>
<!-- Spec-zone 336x280 H2 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-2514821055276660"
     data-ad-slot="9619772848"></ins>
<ul>
<li><a href="../../guides/javac/index.html">Руководство по javac</a></li>
<li><a href="java.html">java</a> - Средство запуска Приложения Java</li>
<li><a href="jdb.html">jdb</a> - Отладчик Приложения Java</li>
<li><a href="javah.html">javah</a> - C Заголовок и Тупиковый Генератор Файла</li>
<li><a href="javap.html">javap</a> - Дизассемблер Файла Класса</li>
<li><a href="javadoc.html">javadoc</a> - Генератор Документации API</li>
<li><a href="jar.html">фляга</a> - Инструмент Архива JAR</li>
<li><a href="../../guides/extensions/index.html">Платформа Расширений Java</a></li>
</ul>

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">

<a href="../../../legal/cpyr.html">Авторское право ©</a> 1993, 2011, Oracle и/или его филиалы. Все права защищены.</div>
<div id="javasecontactus">
<noindex><a rel="nofollow" href="http://download.oracle.com/javase/feedback.html">Свяжитесь с Нами</a></noindex>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

<!-- tBottom -->


<br>
<br>
<br>
<a href="http://spec-zone.ru">Spec-Zone.ru - all specs in one place</a><br>
<br>

<br>
<br>


 <span style="color:#777; font-size:0.8em"> <hr />  <br>  </span> </body>
</html>
